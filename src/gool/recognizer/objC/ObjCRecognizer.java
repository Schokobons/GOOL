/*
 * Copyright 2010 Pablo Arrighi, Alex Concha, Miguel Lezama for version 1.
 * Copyright 2013 Pablo Arrighi, Miguel Lezama, Kevin Mazet for version 2.    
 *
 * This file is part of GOOL.
 *
 * GOOL is free software: you can redistribute it and/or modify it under the terms of the GNU
 * General Public License as published by the Free Software Foundation, version 3.
 *
 * GOOL is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License version 3 for more details.
 *
 * You should have received a copy of the GNU General Public License along with GOOL,
 * in the file COPYING.txt.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * This is a Visitor. It visits the Java abstract syntax tree generated by Sun's java parser, to produce a GOOL abstract syntax tree.
 * 
 */

package gool.recognizer.objC;

import DepotParser.Node;

/**
 * The ObjCRecognizer does the work of converting javacc's abstract ObjC to
 * abstract GOOL.
 */	
//Un visiteur implémente des méthodes visit lors du parcours
//des noeux construits par le parseur. Elles sont spécifiées
//dans la classe abstraite Visitor.

//Le recognizer implémente les méthodes abstraites du visiteur.
class ObjCRecognizer extends Visitor{
	//switch
	

	@Override
	void visit(Node n) {
		switch (n.getKind()) {
		/*"TranslationUnit", //0
			case 0:
			break;
	    "ExternalDeclaration", //1
			case 1:
			break;
	    "StrippedParens", //2
			case 2:
			break;
	    "FunctionDefinition", //3
			case 3:
			break;
	    "Declaration", //4
			case 4:
			break;
	    "ClassInterface", //5
			case 5:
			break;
	    "ClassImplementation", //6
			case 6:
			break;
	    "CategoryInterface", //7
			case 7:
			break;
	    "CategoryImplementation", //8
			case 8:
			break;
	    "ProtocolDeclaration", //9
			case 9:
			break;
	    "ClassDeclarationList", //10
			case 10:
			break;
	    "ClassList", //11
			case 11:
			break;
	    "ProtocolReferenceList", //12
			case 12:
			break;
	    "ProtocolList", //13
			case 13:
			break;
	    "ObjCIDENT", //14
			case 14:
			break;
	    "ClassName", //15
			case 15:
			break;
	    "SuperClassName", //16
			case 16:
			break;
	    "ColonSuperClassName", //17
			case 17:
			break;
	    "CategoryName", //18
			case 18:
			break;
	    "ProtocolName", //19
			case 19:
			break;
	    "InstanceVariables", //20
			case 20:
			break;
	    "InstanceVariableDeclaration", //21
			case 21:
			break;
	    "InstanceVariableDeclarator", //22
			case 22:
			break;
	    "VisibilitySpecification", //23
			case 23:
			break;
	    "IBOutlet", //24
			case 24:
			break;
	    "ProtocolInterfaceDeclaration", //25
			case 25:
			break;
	    "QualifiedProtocolInterfaceDeclaration", //26
			case 26:
			break;
	    "InterfaceDeclaration", //27
			case 27:
			break;
	    "PropertyDeclaration", //28
			case 28:
			break;
	    "PropertyAttributesDeclaration", //29
			case 29:
			break;
	    "PropertyAttributesList", //30
			case 30:
			break;
	    "PropertyAttribute", //31
			case 31:
			break;
	    "MethodDeclaration", //32
			case 32:
			break;
	    "ClassMethodDeclaration", //33
			case 33:
			break;
	    "InstanceMethodDeclaration", //34
			case 34:
			break;
	    "ImplementationDefinition", //35
			case 35:
			break;
	    "PropertyImplementation", //36
			case 36:
			break;
	    "PropertySynthesizeList", //37
			case 37:
			break;
	    "PropertySynthesizeItem", //38
			case 38:
			break;
	    "MethodDefinition", //39
			case 39:
			break;
	    "ClassMethodDefinition", //40
			case 40:
			break;
	    "InstanceMethodDefinition", //41
			case 41:
			break;
	    "MethodSelectorNoList", //42
			case 42:
			break;
	    "MethodSelector", //43
			case 43:
			break;
	    "UnarySelector", //44
			case 44:
			break;
	    "KeywordSelector", //45
			case 45:
			break;
	    "KeywordDeclarator", //46
			case 46:
			break;
	    "Selector", //47
			case 47:
			break;
	    "MethodType", //48
			case 48:
			break;
	    "SelectorExpression", //49
			case 49:
			break;
	    "SelectorName", //50
			case 50:
			break;
	    "KeywordName", //51
			case 51:
			break;
	    "ProtocolExpression", //52
			case 52:
			break;
	    "EncodeExpression", //53
			case 53:
			break;
	    "DeclarationList", //54
			case 54:
			break;
	    "DeclarationSpecifiers", //55
			case 55:
			break;
	    "StorageClassSpecifier", //56
			case 56:
			break;
	    "TypeSpecifier", //57
			case 57:
			break;
	    "GreedyFixedNumType", //58
			case 58:
			break;
	    "PossibleCocoaType", //59
			case 59:
			break;
	    "PossibleCoreType", //60
			case 60:
			break;
	    "PossibleUnknownType", //61
			case 61:
			break;
	    "TypeSpecifierWithUnknownType", //62
			case 62:
			break;
	    "TypeQualifier", //63
			case 63:
			break;
	    "StructOrUnionSpecifier", //64
			case 64:
			break;
	    "StructOrUnion", //65
			case 65:
			break;
	    "StructDeclarationList", //66
			case 66:
			break;
	    "InitDeclaratorList", //67
			case 67:
			break;
	    "InitDeclarator", //68
			case 68:
			break;
	    "ProtocolQualifier", //69
			case 69:
			break;
	    "In", //70
			case 70:
			break;
	    "StructDeclaration", //71
			case 71:
			break;
	    "SpecifierQualifierWithUnknownType", //72
			case 72:
			break;
	    "SpecifierQualifierList", //73
			case 73:
			break;
	    "StructDeclaratorList", //74
			case 74:
			break;
	    "StructDeclarator", //75
			case 75:
			break;
	    "EnumSpecifier", //76
			case 76:
			break;
	    "EnumeratorList", //77
			case 77:
			break;
	    "Enumerator", //78
			case 78:
			break;
	    "Declarator", //79
			case 79:
			break;
	    "Block", //80
			case 80:
			break;
	    "DirectDeclarator", //81
			case 81:
			break;
	    "Pointer", //82
			case 82:
			break;
	    "TypeQualifierList", //83
			case 83:
			break;
	    "ParameterTypeList", //84
			case 84:
			break;
	    "ParameterList", //85
			case 85:
			break;
	    "ParameterDeclaration", //86
			case 86:
			break;
	    "IdentifierList", //87
			case 87:
			break;
	    "Initializer", //88
			case 88:
			break;
	    "InitializerList", //89
			case 89:
			break;
	    "TypeName", //90
			case 90:
			break;
	    "TypeNameWithUnknownType", //91
			case 91:
			break;
	    "AbstractDeclarator", //92
			case 92:
			break;
	    "DirectAbstractDeclarator", //93
			case 93:
			break;
	    "TypedefName", //94
			case 94:
			break;
	    "Statement", //95
			case 95:
			break;
	    "LabeledStatement", //96
			case 96:
			break;
	    "InitStatement", //97
			case 97:
			break;
	    "ExpressionStatement", //98
			case 98:
			break;
	    "CompoundStatement", //99
			case 99:
			break;
	    "StatementList", //100
			case 100:
			break;
	    "SelectionStatement", //101
			case 101:
			break;
	    "NestedLogicalExpression", //102
			case 102:
			break;
	    "LogicalOperator", //103
			case 103:
			break;
	    "IterationStatement", //104
			case 104:
			break;
	    "NumberTypeInit", //105
			case 105:
			break;
	    "JumpStatement", //106
			case 106:
			break;
	    "Expression", //107
			case 107:
			break;
	    "AssignmentExpression", //108
			case 108:
			break;
	    "AssignmentOperator", //109
			case 109:
			break;
	    "ConditionalExpression", //110
			case 110:
			break;
	    "ConstantExpression", //111
			case 111:
			break;
	    "LogicalORExpression", //112
			case 112:
			break;
	    "LogicalANDExpression", //113
			case 113:
			break;
	    "InclusiveORExpression", //114
			case 114:
			break;
	    "ExclusiveORExpression", //115
			case 115:
			break;
	    "ANDExpression", //116
			case 116:
			break;
	    "EqualityExpression", //117
			case 117:
			break;
	    "RelationalExpression", //118
			case 118:
			break;
	    "ShiftExpression", //119
			case 119:
			break;
	    "AdditiveExpression", //120
			case 120:
			break;
	    "MultiplicativeExpression", //121
			case 121:
			break;
	    "CastExpression", //122
			case 122:
			break;
	    "UnaryExpression", //123
			case 123:
			break;
	    "UnaryOperator", //124
			case 124:
			break;
	    "PostfixExpression", //125
			case 125:
			break;
	    "PrimaryExpression", //126
			case 126:
			break;
	    "MessageExpression", //127
			case 127:
			break;
	    "Receiver", //128
			case 128:
			break;
	    "TypeDefedIDENT", //129
			case 129:
			break;
	    "MessageSelector", //130
			case 130:
			break;
	    "KeywordArgument", //131
			case 131:
			break;
	    "ArgumentExpressionList", //132
			case 132:
			break;
	    "Constant", //133*/
		case 133:
		break;
		}
	}
	
	void visitIntExp(Node e) 
	{ 
	  // System.out.print(e.value); 
	} 

	void visitAddExp(Node e) 
	{ 
	  //e.e1.accept(this); 
	  //System.out.print(" + "); 
	  //e.e2.accept(this); 
	}

}